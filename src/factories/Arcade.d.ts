/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
	ethers,
	EventFilter,
	Signer,
	BigNumber,
	BigNumberish,
	PopulatedTransaction,
	BaseContract,
	ContractTransaction,
	Overrides,
	PayableOverrides,
	CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface ArcadeInterface extends ethers.utils.Interface {
	functions: {
		"MaxSupply()": FunctionFragment;
		"Price()": FunctionFragment;
		"approve(address,uint256)": FunctionFragment;
		"armor(uint256)": FunctionFragment;
		"armorURI(uint256)": FunctionFragment;
		"attribute(uint256,uint8)": FunctionFragment;
		"background(uint256)": FunctionFragment;
		"backgroundURI(uint256)": FunctionFragment;
		"balanceOf(address)": FunctionFragment;
		"baseURI()": FunctionFragment;
		"burn(uint256)": FunctionFragment;
		"character(uint256)": FunctionFragment;
		"characterURI(uint256)": FunctionFragment;
		"componentsBaseURI()": FunctionFragment;
		"contractURI()": FunctionFragment;
		"customeURIs(uint256)": FunctionFragment;
		"earmuff(uint256)": FunctionFragment;
		"earmuffURI(uint256)": FunctionFragment;
		"gem(uint256)": FunctionFragment;
		"gemURI(uint256)": FunctionFragment;
		"generateMetaId(uint256)": FunctionFragment;
		"getApproved(uint256)": FunctionFragment;
		"helmet(uint256)": FunctionFragment;
		"helmetURI(uint256)": FunctionFragment;
		"isApprovedForAll(address,address)": FunctionFragment;
		"isOpen()": FunctionFragment;
		"isWhiteAllowed(address)": FunctionFragment;
		"isWhiteMinted(address)": FunctionFragment;
		"isWhiteOpen()": FunctionFragment;
		"level(uint256)": FunctionFragment;
		"levelSteps(uint256)": FunctionFragment;
		"levelURI(uint256)": FunctionFragment;
		"mask(uint256)": FunctionFragment;
		"maskURI(uint256)": FunctionFragment;
		"metaIdExsits(uint256)": FunctionFragment;
		"metaIds(uint256)": FunctionFragment;
		"mint(address)": FunctionFragment;
		"name()": FunctionFragment;
		"owner()": FunctionFragment;
		"ownerMint(address,uint256)": FunctionFragment;
		"ownerOf(uint256)": FunctionFragment;
		"ownerSet(address,uint256[])": FunctionFragment;
		"receiver()": FunctionFragment;
		"renounceOwnership()": FunctionFragment;
		"safeTransferFrom(address,address,uint256)": FunctionFragment;
		"sale()": FunctionFragment;
		"saleStart()": FunctionFragment;
		"setApprovalForAll(address,bool)": FunctionFragment;
		"setBaseURI(string)": FunctionFragment;
		"setComponentsBaseURI(string)": FunctionFragment;
		"setContractURI(string)": FunctionFragment;
		"setCustomeURIs(uint256,string)": FunctionFragment;
		"setMaxSupply(uint256)": FunctionFragment;
		"setWhitelist(address[],bool)": FunctionFragment;
		"supportsInterface(bytes4)": FunctionFragment;
		"symbol()": FunctionFragment;
		"tokenByIndex(uint256)": FunctionFragment;
		"tokenOfOwnerByIndex(address,uint256)": FunctionFragment;
		"tokenURI(uint256)": FunctionFragment;
		"totalSupply()": FunctionFragment;
		"totalWhiteList()": FunctionFragment;
		"transferFrom(address,address,uint256)": FunctionFragment;
		"transferOwnership(address)": FunctionFragment;
		"transferTokenReceiver(address)": FunctionFragment;
		"whiteMint(address)": FunctionFragment;
		"whiteSale()": FunctionFragment;
		"whitelist(address)": FunctionFragment;
	};

	encodeFunctionData(functionFragment: "MaxSupply", values?: undefined): string;
	encodeFunctionData(functionFragment: "Price", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "approve",
		values: [string, BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "armor", values: [BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "armorURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "attribute",
		values: [BigNumberish, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "background",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "backgroundURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
	encodeFunctionData(functionFragment: "baseURI", values?: undefined): string;
	encodeFunctionData(functionFragment: "burn", values: [BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "character",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "characterURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "componentsBaseURI",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "contractURI",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "customeURIs",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "earmuff",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "earmuffURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "gem", values: [BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "gemURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "generateMetaId",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "getApproved",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "helmet",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "helmetURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "isApprovedForAll",
		values: [string, string]
	): string;
	encodeFunctionData(functionFragment: "isOpen", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "isWhiteAllowed",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "isWhiteMinted",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "isWhiteOpen",
		values?: undefined
	): string;
	encodeFunctionData(functionFragment: "level", values: [BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "levelSteps",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "levelURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "mask", values: [BigNumberish]): string;
	encodeFunctionData(
		functionFragment: "maskURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "metaIdExsits",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "metaIds",
		values: [BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "mint", values: [string]): string;
	encodeFunctionData(functionFragment: "name", values?: undefined): string;
	encodeFunctionData(functionFragment: "owner", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "ownerMint",
		values: [string, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "ownerOf",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "ownerSet",
		values: [string, BigNumberish[]]
	): string;
	encodeFunctionData(functionFragment: "receiver", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "renounceOwnership",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "safeTransferFrom",
		values: [string, string, BigNumberish]
	): string;
	encodeFunctionData(functionFragment: "sale", values?: undefined): string;
	encodeFunctionData(functionFragment: "saleStart", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "setApprovalForAll",
		values: [string, boolean]
	): string;
	encodeFunctionData(functionFragment: "setBaseURI", values: [string]): string;
	encodeFunctionData(
		functionFragment: "setComponentsBaseURI",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "setContractURI",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "setCustomeURIs",
		values: [BigNumberish, string]
	): string;
	encodeFunctionData(
		functionFragment: "setMaxSupply",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "setWhitelist",
		values: [string[], boolean]
	): string;
	encodeFunctionData(
		functionFragment: "supportsInterface",
		values: [BytesLike]
	): string;
	encodeFunctionData(functionFragment: "symbol", values?: undefined): string;
	encodeFunctionData(
		functionFragment: "tokenByIndex",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "tokenOfOwnerByIndex",
		values: [string, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "tokenURI",
		values: [BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "totalSupply",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "totalWhiteList",
		values?: undefined
	): string;
	encodeFunctionData(
		functionFragment: "transferFrom",
		values: [string, string, BigNumberish]
	): string;
	encodeFunctionData(
		functionFragment: "transferOwnership",
		values: [string]
	): string;
	encodeFunctionData(
		functionFragment: "transferTokenReceiver",
		values: [string]
	): string;
	encodeFunctionData(functionFragment: "whiteMint", values: [string]): string;
	encodeFunctionData(functionFragment: "whiteSale", values?: undefined): string;
	encodeFunctionData(functionFragment: "whitelist", values: [string]): string;

	decodeFunctionResult(functionFragment: "MaxSupply", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "Price", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "armor", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "armorURI", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "attribute", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "background", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "backgroundURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "baseURI", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "burn", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "character", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "characterURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "componentsBaseURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "contractURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "customeURIs",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "earmuff", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "earmuffURI", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "gem", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "gemURI", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "generateMetaId",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "getApproved",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "helmet", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "helmetURI", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "isApprovedForAll",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "isOpen", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "isWhiteAllowed",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "isWhiteMinted",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "isWhiteOpen",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "level", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "levelSteps", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "levelURI", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "mask", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "maskURI", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "metaIdExsits",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "metaIds", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ownerMint", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ownerOf", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "ownerSet", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "receiver", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "renounceOwnership",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "safeTransferFrom",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "sale", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "saleStart", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "setApprovalForAll",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "setBaseURI", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "setComponentsBaseURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "setContractURI",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "setCustomeURIs",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "setMaxSupply",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "setWhitelist",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "supportsInterface",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "symbol", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "tokenByIndex",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "tokenOfOwnerByIndex",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "tokenURI", data: BytesLike): Result;
	decodeFunctionResult(
		functionFragment: "totalSupply",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "totalWhiteList",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "transferFrom",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "transferOwnership",
		data: BytesLike
	): Result;
	decodeFunctionResult(
		functionFragment: "transferTokenReceiver",
		data: BytesLike
	): Result;
	decodeFunctionResult(functionFragment: "whiteMint", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "whiteSale", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "whitelist", data: BytesLike): Result;

	events: {
		"Approval(address,address,uint256)": EventFragment;
		"ApprovalForAll(address,address,bool)": EventFragment;
		"OwnershipTransferred(address,address)": EventFragment;
		"Transfer(address,address,uint256)": EventFragment;
	};

	getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "ApprovalForAll"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
	getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
}

export type ApprovalEvent = TypedEvent<
	[string, string, BigNumber] & {
		owner: string;
		approved: string;
		tokenId: BigNumber;
	}
>;

export type ApprovalForAllEvent = TypedEvent<
	[string, string, boolean] & {
		owner: string;
		operator: string;
		approved: boolean;
	}
>;

export type OwnershipTransferredEvent = TypedEvent<
	[string, string] & { previousOwner: string; newOwner: string }
>;

export type TransferEvent = TypedEvent<
	[string, string, BigNumber] & { from: string; to: string; tokenId: BigNumber }
>;

export class Arcade extends BaseContract {
	connect(signerOrProvider: Signer | Provider | string): this;
	attach(addressOrName: string): this;
	deployed(): Promise<this>;

	listeners<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
	): Array<TypedListener<EventArgsArray, EventArgsObject>>;
	off<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	on<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	once<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
		listener: TypedListener<EventArgsArray, EventArgsObject>
	): this;
	removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
		eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
	): this;

	listeners(eventName?: string): Array<Listener>;
	off(eventName: string, listener: Listener): this;
	on(eventName: string, listener: Listener): this;
	once(eventName: string, listener: Listener): this;
	removeListener(eventName: string, listener: Listener): this;
	removeAllListeners(eventName?: string): this;

	queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
		event: TypedEventFilter<EventArgsArray, EventArgsObject>,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined
	): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

	interface: ArcadeInterface;

	functions: {
		MaxSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

		Price(overrides?: CallOverrides): Promise<[BigNumber]>;

		approve(
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		armor(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		armorURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		attribute(
			tokenId: BigNumberish,
			attributeTag: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		background(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		backgroundURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		balanceOf(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;

		baseURI(overrides?: CallOverrides): Promise<[string]>;

		burn(
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		character(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		characterURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		componentsBaseURI(overrides?: CallOverrides): Promise<[string]>;

		contractURI(overrides?: CallOverrides): Promise<[string]>;

		customeURIs(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		earmuff(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		earmuffURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		gem(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

		gemURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

		generateMetaId(
			randomId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		getApproved(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		helmet(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		helmetURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		isApprovedForAll(
			owner: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<[boolean]>;

		isOpen(overrides?: CallOverrides): Promise<[boolean]>;

		isWhiteAllowed(to: string, overrides?: CallOverrides): Promise<[boolean]>;

		isWhiteMinted(to: string, overrides?: CallOverrides): Promise<[boolean]>;

		isWhiteOpen(overrides?: CallOverrides): Promise<[boolean]>;

		level(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		levelSteps(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<[number]>;

		levelURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		mask(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		maskURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		metaIdExsits(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<[boolean]>;

		metaIds(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		mint(
			to: string,
			overrides?: PayableOverrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		name(overrides?: CallOverrides): Promise<[string]>;

		owner(overrides?: CallOverrides): Promise<[string]>;

		ownerMint(
			to: string,
			amount: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		ownerOf(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		ownerSet(
			to: string,
			metas: BigNumberish[],
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		receiver(overrides?: CallOverrides): Promise<[string]>;

		renounceOwnership(
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		"safeTransferFrom(address,address,uint256)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		"safeTransferFrom(address,address,uint256,bytes)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			_data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		sale(overrides?: CallOverrides): Promise<[BigNumber]>;

		saleStart(overrides?: CallOverrides): Promise<[BigNumber]>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setBaseURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setComponentsBaseURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setContractURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setCustomeURIs(
			tokenId: BigNumberish,
			uri: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setMaxSupply(
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		setWhitelist(
			whitelist_: string[],
			isAllowed: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<[boolean]>;

		symbol(overrides?: CallOverrides): Promise<[string]>;

		tokenByIndex(
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		tokenOfOwnerByIndex(
			owner: string,
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<[BigNumber]>;

		tokenURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<[string]>;

		totalSupply(overrides?: CallOverrides): Promise<[BigNumber]>;

		totalWhiteList(overrides?: CallOverrides): Promise<[BigNumber]>;

		transferFrom(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		transferOwnership(
			newOwner: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		transferTokenReceiver(
			newReceiver: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		whiteMint(
			to: string,
			overrides?: PayableOverrides & { from?: string | Promise<string> }
		): Promise<ContractTransaction>;

		whiteSale(overrides?: CallOverrides): Promise<[BigNumber]>;

		whitelist(
			arg0: string,
			overrides?: CallOverrides
		): Promise<[boolean, boolean] & { isAllowed: boolean; isMinted: boolean }>;
	};

	MaxSupply(overrides?: CallOverrides): Promise<BigNumber>;

	Price(overrides?: CallOverrides): Promise<BigNumber>;

	approve(
		to: string,
		tokenId: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	armor(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	armorURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	attribute(
		tokenId: BigNumberish,
		attributeTag: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	background(
		tokenId: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	backgroundURI(
		tokenId: BigNumberish,
		overrides?: CallOverrides
	): Promise<string>;

	balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

	baseURI(overrides?: CallOverrides): Promise<string>;

	burn(
		tokenId: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	character(
		tokenId: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	characterURI(
		tokenId: BigNumberish,
		overrides?: CallOverrides
	): Promise<string>;

	componentsBaseURI(overrides?: CallOverrides): Promise<string>;

	contractURI(overrides?: CallOverrides): Promise<string>;

	customeURIs(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

	earmuff(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	earmuffURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	gem(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	gemURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	generateMetaId(
		randomId: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	getApproved(
		tokenId: BigNumberish,
		overrides?: CallOverrides
	): Promise<string>;

	helmet(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	helmetURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	isApprovedForAll(
		owner: string,
		operator: string,
		overrides?: CallOverrides
	): Promise<boolean>;

	isOpen(overrides?: CallOverrides): Promise<boolean>;

	isWhiteAllowed(to: string, overrides?: CallOverrides): Promise<boolean>;

	isWhiteMinted(to: string, overrides?: CallOverrides): Promise<boolean>;

	isWhiteOpen(overrides?: CallOverrides): Promise<boolean>;

	level(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	levelSteps(arg0: BigNumberish, overrides?: CallOverrides): Promise<number>;

	levelURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	mask(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	maskURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	metaIdExsits(arg0: BigNumberish, overrides?: CallOverrides): Promise<boolean>;

	metaIds(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

	mint(
		to: string,
		overrides?: PayableOverrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	name(overrides?: CallOverrides): Promise<string>;

	owner(overrides?: CallOverrides): Promise<string>;

	ownerMint(
		to: string,
		amount: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	ownerSet(
		to: string,
		metas: BigNumberish[],
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	receiver(overrides?: CallOverrides): Promise<string>;

	renounceOwnership(
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	"safeTransferFrom(address,address,uint256)"(
		from: string,
		to: string,
		tokenId: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	"safeTransferFrom(address,address,uint256,bytes)"(
		from: string,
		to: string,
		tokenId: BigNumberish,
		_data: BytesLike,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	sale(overrides?: CallOverrides): Promise<BigNumber>;

	saleStart(overrides?: CallOverrides): Promise<BigNumber>;

	setApprovalForAll(
		operator: string,
		approved: boolean,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setBaseURI(
		uri_: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setComponentsBaseURI(
		uri_: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setContractURI(
		uri_: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setCustomeURIs(
		tokenId: BigNumberish,
		uri: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setMaxSupply(
		supply: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	setWhitelist(
		whitelist_: string[],
		isAllowed: boolean,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	supportsInterface(
		interfaceId: BytesLike,
		overrides?: CallOverrides
	): Promise<boolean>;

	symbol(overrides?: CallOverrides): Promise<string>;

	tokenByIndex(
		index: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	tokenOfOwnerByIndex(
		owner: string,
		index: BigNumberish,
		overrides?: CallOverrides
	): Promise<BigNumber>;

	tokenURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

	totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

	totalWhiteList(overrides?: CallOverrides): Promise<BigNumber>;

	transferFrom(
		from: string,
		to: string,
		tokenId: BigNumberish,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	transferOwnership(
		newOwner: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	transferTokenReceiver(
		newReceiver: string,
		overrides?: Overrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	whiteMint(
		to: string,
		overrides?: PayableOverrides & { from?: string | Promise<string> }
	): Promise<ContractTransaction>;

	whiteSale(overrides?: CallOverrides): Promise<BigNumber>;

	whitelist(
		arg0: string,
		overrides?: CallOverrides
	): Promise<[boolean, boolean] & { isAllowed: boolean; isMinted: boolean }>;

	callStatic: {
		MaxSupply(overrides?: CallOverrides): Promise<BigNumber>;

		Price(overrides?: CallOverrides): Promise<BigNumber>;

		approve(
			to: string,
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		armor(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		armorURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		attribute(
			tokenId: BigNumberish,
			attributeTag: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		background(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		backgroundURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<string>;

		balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

		baseURI(overrides?: CallOverrides): Promise<string>;

		burn(tokenId: BigNumberish, overrides?: CallOverrides): Promise<void>;

		character(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		characterURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<string>;

		componentsBaseURI(overrides?: CallOverrides): Promise<string>;

		contractURI(overrides?: CallOverrides): Promise<string>;

		customeURIs(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

		earmuff(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		earmuffURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<string>;

		gem(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		gemURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		generateMetaId(
			randomId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		getApproved(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<string>;

		helmet(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		helmetURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<string>;

		isApprovedForAll(
			owner: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<boolean>;

		isOpen(overrides?: CallOverrides): Promise<boolean>;

		isWhiteAllowed(to: string, overrides?: CallOverrides): Promise<boolean>;

		isWhiteMinted(to: string, overrides?: CallOverrides): Promise<boolean>;

		isWhiteOpen(overrides?: CallOverrides): Promise<boolean>;

		level(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		levelSteps(arg0: BigNumberish, overrides?: CallOverrides): Promise<number>;

		levelURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		mask(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		maskURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		metaIdExsits(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<boolean>;

		metaIds(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		mint(to: string, overrides?: CallOverrides): Promise<void>;

		name(overrides?: CallOverrides): Promise<string>;

		owner(overrides?: CallOverrides): Promise<string>;

		ownerMint(
			to: string,
			amount: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		ownerOf(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		ownerSet(
			to: string,
			metas: BigNumberish[],
			overrides?: CallOverrides
		): Promise<void>;

		receiver(overrides?: CallOverrides): Promise<string>;

		renounceOwnership(overrides?: CallOverrides): Promise<void>;

		"safeTransferFrom(address,address,uint256)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		"safeTransferFrom(address,address,uint256,bytes)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			_data: BytesLike,
			overrides?: CallOverrides
		): Promise<void>;

		sale(overrides?: CallOverrides): Promise<BigNumber>;

		saleStart(overrides?: CallOverrides): Promise<BigNumber>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: CallOverrides
		): Promise<void>;

		setBaseURI(uri_: string, overrides?: CallOverrides): Promise<void>;

		setComponentsBaseURI(
			uri_: string,
			overrides?: CallOverrides
		): Promise<void>;

		setContractURI(uri_: string, overrides?: CallOverrides): Promise<void>;

		setCustomeURIs(
			tokenId: BigNumberish,
			uri: string,
			overrides?: CallOverrides
		): Promise<void>;

		setMaxSupply(
			supply: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		setWhitelist(
			whitelist_: string[],
			isAllowed: boolean,
			overrides?: CallOverrides
		): Promise<void>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<boolean>;

		symbol(overrides?: CallOverrides): Promise<string>;

		tokenByIndex(
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		tokenOfOwnerByIndex(
			owner: string,
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		tokenURI(tokenId: BigNumberish, overrides?: CallOverrides): Promise<string>;

		totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

		totalWhiteList(overrides?: CallOverrides): Promise<BigNumber>;

		transferFrom(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<void>;

		transferOwnership(
			newOwner: string,
			overrides?: CallOverrides
		): Promise<void>;

		transferTokenReceiver(
			newReceiver: string,
			overrides?: CallOverrides
		): Promise<void>;

		whiteMint(to: string, overrides?: CallOverrides): Promise<void>;

		whiteSale(overrides?: CallOverrides): Promise<BigNumber>;

		whitelist(
			arg0: string,
			overrides?: CallOverrides
		): Promise<[boolean, boolean] & { isAllowed: boolean; isMinted: boolean }>;
	};

	filters: {
		"Approval(address,address,uint256)"(
			owner?: string | null,
			approved?: string | null,
			tokenId?: BigNumberish | null
		): TypedEventFilter<
			[string, string, BigNumber],
			{ owner: string; approved: string; tokenId: BigNumber }
		>;

		Approval(
			owner?: string | null,
			approved?: string | null,
			tokenId?: BigNumberish | null
		): TypedEventFilter<
			[string, string, BigNumber],
			{ owner: string; approved: string; tokenId: BigNumber }
		>;

		"ApprovalForAll(address,address,bool)"(
			owner?: string | null,
			operator?: string | null,
			approved?: null
		): TypedEventFilter<
			[string, string, boolean],
			{ owner: string; operator: string; approved: boolean }
		>;

		ApprovalForAll(
			owner?: string | null,
			operator?: string | null,
			approved?: null
		): TypedEventFilter<
			[string, string, boolean],
			{ owner: string; operator: string; approved: boolean }
		>;

		"OwnershipTransferred(address,address)"(
			previousOwner?: string | null,
			newOwner?: string | null
		): TypedEventFilter<
			[string, string],
			{ previousOwner: string; newOwner: string }
		>;

		OwnershipTransferred(
			previousOwner?: string | null,
			newOwner?: string | null
		): TypedEventFilter<
			[string, string],
			{ previousOwner: string; newOwner: string }
		>;

		"Transfer(address,address,uint256)"(
			from?: string | null,
			to?: string | null,
			tokenId?: BigNumberish | null
		): TypedEventFilter<
			[string, string, BigNumber],
			{ from: string; to: string; tokenId: BigNumber }
		>;

		Transfer(
			from?: string | null,
			to?: string | null,
			tokenId?: BigNumberish | null
		): TypedEventFilter<
			[string, string, BigNumber],
			{ from: string; to: string; tokenId: BigNumber }
		>;
	};

	estimateGas: {
		MaxSupply(overrides?: CallOverrides): Promise<BigNumber>;

		Price(overrides?: CallOverrides): Promise<BigNumber>;

		approve(
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		armor(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		armorURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		attribute(
			tokenId: BigNumberish,
			attributeTag: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		background(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		backgroundURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		balanceOf(owner: string, overrides?: CallOverrides): Promise<BigNumber>;

		baseURI(overrides?: CallOverrides): Promise<BigNumber>;

		burn(
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		character(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		characterURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		componentsBaseURI(overrides?: CallOverrides): Promise<BigNumber>;

		contractURI(overrides?: CallOverrides): Promise<BigNumber>;

		customeURIs(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		earmuff(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		earmuffURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		gem(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		gemURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		generateMetaId(
			randomId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		getApproved(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		helmet(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		helmetURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		isApprovedForAll(
			owner: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		isOpen(overrides?: CallOverrides): Promise<BigNumber>;

		isWhiteAllowed(to: string, overrides?: CallOverrides): Promise<BigNumber>;

		isWhiteMinted(to: string, overrides?: CallOverrides): Promise<BigNumber>;

		isWhiteOpen(overrides?: CallOverrides): Promise<BigNumber>;

		level(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		levelSteps(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		levelURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		mask(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		maskURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		metaIdExsits(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		metaIds(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

		mint(
			to: string,
			overrides?: PayableOverrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		name(overrides?: CallOverrides): Promise<BigNumber>;

		owner(overrides?: CallOverrides): Promise<BigNumber>;

		ownerMint(
			to: string,
			amount: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		ownerOf(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		ownerSet(
			to: string,
			metas: BigNumberish[],
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		receiver(overrides?: CallOverrides): Promise<BigNumber>;

		renounceOwnership(
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		"safeTransferFrom(address,address,uint256)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		"safeTransferFrom(address,address,uint256,bytes)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			_data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		sale(overrides?: CallOverrides): Promise<BigNumber>;

		saleStart(overrides?: CallOverrides): Promise<BigNumber>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setBaseURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setComponentsBaseURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setContractURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setCustomeURIs(
			tokenId: BigNumberish,
			uri: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setMaxSupply(
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		setWhitelist(
			whitelist_: string[],
			isAllowed: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		symbol(overrides?: CallOverrides): Promise<BigNumber>;

		tokenByIndex(
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		tokenOfOwnerByIndex(
			owner: string,
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		tokenURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<BigNumber>;

		totalSupply(overrides?: CallOverrides): Promise<BigNumber>;

		totalWhiteList(overrides?: CallOverrides): Promise<BigNumber>;

		transferFrom(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		transferOwnership(
			newOwner: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		transferTokenReceiver(
			newReceiver: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		whiteMint(
			to: string,
			overrides?: PayableOverrides & { from?: string | Promise<string> }
		): Promise<BigNumber>;

		whiteSale(overrides?: CallOverrides): Promise<BigNumber>;

		whitelist(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
	};

	populateTransaction: {
		MaxSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		Price(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		approve(
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		armor(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		armorURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		attribute(
			tokenId: BigNumberish,
			attributeTag: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		background(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		backgroundURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		balanceOf(
			owner: string,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		baseURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		burn(
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		character(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		characterURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		componentsBaseURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		contractURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		customeURIs(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		earmuff(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		earmuffURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		gem(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		gemURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		generateMetaId(
			randomId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		getApproved(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		helmet(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		helmetURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		isApprovedForAll(
			owner: string,
			operator: string,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		isOpen(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		isWhiteAllowed(
			to: string,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		isWhiteMinted(
			to: string,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		isWhiteOpen(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		level(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		levelSteps(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		levelURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		mask(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		maskURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		metaIdExsits(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		metaIds(
			arg0: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		mint(
			to: string,
			overrides?: PayableOverrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		name(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		ownerMint(
			to: string,
			amount: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		ownerOf(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		ownerSet(
			to: string,
			metas: BigNumberish[],
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		receiver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		renounceOwnership(
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		"safeTransferFrom(address,address,uint256)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		"safeTransferFrom(address,address,uint256,bytes)"(
			from: string,
			to: string,
			tokenId: BigNumberish,
			_data: BytesLike,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		sale(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		saleStart(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		setApprovalForAll(
			operator: string,
			approved: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setBaseURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setComponentsBaseURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setContractURI(
			uri_: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setCustomeURIs(
			tokenId: BigNumberish,
			uri: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setMaxSupply(
			supply: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		setWhitelist(
			whitelist_: string[],
			isAllowed: boolean,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		supportsInterface(
			interfaceId: BytesLike,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		tokenByIndex(
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		tokenOfOwnerByIndex(
			owner: string,
			index: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		tokenURI(
			tokenId: BigNumberish,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;

		totalSupply(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		totalWhiteList(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		transferFrom(
			from: string,
			to: string,
			tokenId: BigNumberish,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		transferOwnership(
			newOwner: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		transferTokenReceiver(
			newReceiver: string,
			overrides?: Overrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		whiteMint(
			to: string,
			overrides?: PayableOverrides & { from?: string | Promise<string> }
		): Promise<PopulatedTransaction>;

		whiteSale(overrides?: CallOverrides): Promise<PopulatedTransaction>;

		whitelist(
			arg0: string,
			overrides?: CallOverrides
		): Promise<PopulatedTransaction>;
	};
}
